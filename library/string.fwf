
guard
import one
import int_size
import null

type String (
	length:int
	backinglist:listubyte
	chars:listubyte
	
	function void init(cstring:ptr) {
		this.length = strlen$ cstring
		this.chars = @listubyte malloc$ @uint this.length
		this.backinglist = @listubyte malloc$ + 1u @uint this.length
		strcpy$ this.backinglist cstring
		memcpy$ @ptr this.chars cstring @uint this.length
	}

	function listubyte to_char_list() {
		return this.chars
	}

	function void for_chars(operation:func) {
		for ubyte this.chars with c {
			$ operation @uint c
		}
	}

	function ptr c_str() {
		return @ptr this.backinglist
	}

	function void delete() {
		ifnot = this null {
			free$ this.backinglist
			free$ this.chars
		} ;
	}

	function String append(other:String) {
		result = String$ ""
		result.delete$

		len = @uint + this.length other.length
		result.length = len
		rawchars = malloc$ len
		cstr = malloc$ + 1u len
		result.backinglist = cstr
		result.chars = rawchars
		strcpy$ result.backinglist this.backinglist
		strcpy$ + @ptr result.backinglist this.length other.backinglist
		memcpy$ result.chars result.backinglist len
		return result
	}

	function int to_int() {
		return str_to_int$ this.backinglist
	}

	function bool eq(other:String) {
		return streq$ this.backinglist other.backinglist
	}

	function bool eqs(other:ptr) {
		return streq$ this.backinglist other
	}

	function int compare(other:String) {
		return strcmp$ this.backinglist other.backinglist
	}

	function String join(strings:listptr) {
		
		if = 0u sizeof$ strings {
			return String$ ""
		} ;
		
		myrepeats = -
			/ sizeof$ strings int_size
			1u

		totalLength = + 1u * @uint this.length myrepeats

		for ptr strings with strptr {
			theString = @String strptr
			totalLength = + totalLength @uint theString.length
		}

		placementTarget = malloc$ totalLength
		retval = placementTarget
		firststring = @String deref_ptr$ strings
		strcpy$ placementTarget firststring.backinglist

		placementTarget = + placementTarget firststring.length

		for uint (0u,/ sizeof$ strings int_size) with index {
			strcpy$ placementTarget this.backinglist
			placementTarget = + placementTarget this.length
			theString = @String (index)strings
			strcpy$ placementTarget theString.backinglist
			placementTarget = + placementTarget theString.length
		}
		rv = String$ retval
		free$ retval
		return rv

	}
	//toUpperCase
)

//use String.append if you really want this
function ptr concat(a:ptr b:ptr) {
	finalLen = + 1u + strlen$ a strlen$ b
	retval = malloc$ finalLen
	strcpy$ retval a
	strcpy$ + retval strlen$ a b
	return retval
}

function uint strlen(s:ptr) {
	offset = 0u
	while true {
		x = deref_byte$ s
		if = x 0b {
			return offset
		} {
			s = + s as 1 ptr
			offset = + offset 1u
		}
	}
	return offset
}

import one
function bool streq(str1:ptr str2:ptr) {
	return = 0 strcmp$ str1 str2
}

function bool string_eq(str1:String str2:String) {
	return streq$ str1.backinglist str2.backinglist
}

function int strcmp(str1:ptr str2:ptr) {
	//str1 - str2
	while = deref_byte$ str1 deref_byte$ str2 {
		if = 0b deref_byte$ str1 {//they both terminated at the same time
			return 0
		} {
			str1 = + one str1
			str2 = + one str2
		}
	}
	return  - as deref_ubyte$ str1 int as deref_byte$ str2 int
}


function int str_to_int (num:ptr) {
	//scans the given string for the longest input that matches
	//  /-?[0-9]*
	// parses that as an integer, ignoring overflows
	// ignores anything after the digits
	// str_to_int$ "" = 0
	// str_to_int$ "-" = 0
	// str_to_int$ "100" = 100
	// str_to_int$ "-13wot" = -13
	temp digits = ['0','9']
	reset negative
	read = num
	num1 = 0
	if = deref_ubyte$ num '-' {
		set negative
		read = + read one
	} ;
	while in deref_ubyte$ read digits {
		num1 = + * 10 num1 as - deref_ubyte$ read '0' int
		read = + one read
	}
	if negative {
		num1 = !num1
	} ;
	return num1
}

alias uint string_hash(string:uint)
function uint string_hash(string:ptr) {
	hash = 13u
	whilenot = 0b deref_byte$ string {
		hash = + * hash 41u as deref_ubyte$ string uint
		string = + string one
	}
	return hash
}
