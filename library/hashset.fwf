guard
import null

//
// Structure of a hashset:
// 2048 entries
// @ each index, place a linked list, null terminated
// each node is a listptr. one to the next node, one to the contents
//
//
//
//
//
hashset_size = 512u

function listptr hashset_new() {
	map = @listptr malloc$ ?hashset_size
	for uint [0u,hashset_size) with i {
		assign_word$ map i null
	}
	return map
}

function void delete_hashset_entry(link:ptr) {
	if = link null {
		return
	} {
		delete_hashset_entry$ deref_ptr$ + link @ptr ?1
		free$ link
	}
}

function void hashset_delete(hashset:listptr) {
	for uint [0u,hashset_size) with i {
		delete_hashset_entry$ access_word$ hashset i
	}
	free$ hashset
}

function void hashset_put(hashset:listptr element:ptr hashfunc:func eqfunc:op) {
	index = & - hashset_size 1u @uint $ hashfunc element
	node = access_word$ hashset index
	location = + @ptr ?index @ptr hashset
	whilenot = node null {
		//either this is the element and I can return, or it's not and I continue
		ifnot = 0u binop$ eqfunc @uint access_word$ @listptr node 0u @uint element {
			return
		} {
			location = + @ptr ?1u node
			node = access_word$ @listptr node 1u
		}
	}
	node = malloc$ ?2u
	put_ptr$ location node
	assign_word$ @listptr node 1u null
	assign_word$ @listptr node 0u element
}

function bool hashset_contains(hashset:listptr element:ptr hashfunc:func eqfunc:op) {
	index = & - hashset_size 1u @uint $ hashfunc element
	node = access_word$ hashset index
	location = + @ptr ?index @ptr hashset
	whilenot = node null {
		//either this is the element and I can return, or it's not and I continue
		ifnot = 0u binop$ eqfunc @uint access_word$ @listptr node 0u @uint element {
			return true
		} {
			node = access_word$ @listptr node 1u
		}
	}
	return false
}

function void hashset_foreach(hashset:listptr operation:func) {
	for ptr hashset with element {
		whilenot = null element {
			$ operation access_word$ @listuint element 0u
			element = access_word$ @listptr element 1u
		}
	}
}