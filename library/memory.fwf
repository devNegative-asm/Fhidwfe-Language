null = as 0 ptr
one = as 1 ptr

alias uint sizeof(a:listbyte)
alias uint sizeof(a:listubyte)
alias uint sizeof(a:listptr)
alias uint sizeof(a:listuint)
alias uint sizeof(a:listint)


function uint sizeof(input:ptr) {
	return deref_uint$ - input as ? 1 ptr
}

//memory is held as a linked list with dummy nodes at the beginning and end
//if there is room somewhere in the list, put each new object there

// ? n is the same as n*int_size

function ptr malloc(size:uint) {
	_guard_mem_curobj = heap
	_guard_mem_space = as + size ? 3u ptr
	//need _guard_mem_space for my object + 3 ints
	
	_guard_mem_next = deref_ptr$ - _guard_mem_curobj as ? 2u ptr
	_guard_mem_blocksize = deref_ptr$ - _guard_mem_curobj as int_size ptr
	
	while < - - _guard_mem_next _guard_mem_curobj _guard_mem_blocksize _guard_mem_space {
		_guard_mem_curobj = _guard_mem_next
		_guard_mem_next = deref_ptr$ - _guard_mem_curobj as ? 2u ptr
		_guard_mem_blocksize = deref_ptr$ - _guard_mem_curobj as int_size ptr
		
		if = _guard_mem_next null {
			return null//no room
		} ;
		
	}
	
	_guard_mem_newobjectloc = + + _guard_mem_curobj _guard_mem_blocksize as ? 3u ptr
	
	//header for the new object
	put_uint$ - _guard_mem_newobjectloc as int_size ptr size
	put_ptr$ - _guard_mem_newobjectloc as ? 2u ptr _guard_mem_next
	put_ptr$ - _guard_mem_newobjectloc as ? 3u ptr _guard_mem_curobj
	
	//update _guard_mem_previous object's header
	put_ptr$ - _guard_mem_curobj as ? 2u ptr _guard_mem_newobjectloc
	
	//update _guard_mem_next object's header
	put_ptr$ - _guard_mem_next as ? 3u ptr _guard_mem_newobjectloc
	
	return _guard_mem_newobjectloc
	
}

alias void free(a:listbyte)
alias void free(a:listubyte)
alias void free(a:listptr)
alias void free(a:listuint)
alias void free(a:listint)

alias void free(a:rangecc)
alias void free(a:rangeco)
alias void free(a:rangeoc)
alias void free(a:rangeoo)

alias void free(a:urangecc)
alias void free(a:urangeco)
alias void free(a:urangeoc)
alias void free(a:urangeoo)

alias void free(a:brangecc)
alias void free(a:brangeco)
alias void free(a:brangeoc)
alias void free(a:brangeoo)

alias void free(a:ubrangecc)
alias void free(a:ubrangeco)
alias void free(a:ubrangeoc)
alias void free(a:ubrangeoo)

function void free(block:ptr) {
	if || || = block null < block heap >= block heaptail {
		return
	} ;
	
	_guard_mem_prev = deref_ptr$ - block as ? 3u ptr
	_guard_mem_next = deref_ptr$ - block as ? 2u ptr
	
	put_ptr$ - _guard_mem_prev as ? 2u ptr _guard_mem_next
	put_ptr$ - _guard_mem_next as ? 3u ptr _guard_mem_prev
}
